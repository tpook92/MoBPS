selection.m.database = cbind(1,1,1,1),
selection.f.database = cbind(1,1,2,2),
mutation.rate = mut)
population <- breeding.diploid(population, breeding.size = c(400,0), name.cohort = "CD",
selection.m.database = cbind(1,1,3,3),
selection.f.database = cbind(1,1,4,4),
mutation.rate = mut)
population <- breeding.diploid(population, breeding.size = c(400,0), name.cohort = "EF",
selection.m.database = cbind(1,1,5,5),
selection.f.database = cbind(1,1,6,6),
mutation.rate = mut)
population <- breeding.diploid(population, breeding.size = c(400,0), name.cohort = "GH",
selection.m.database = cbind(1,1,7,7),
selection.f.database = cbind(1,1,8,8),
mutation.rate = mut)
population <- breeding.diploid(population, breeding.size = c(400,0), name.cohort = "ABCD",
selection.m.cohorts = "AB",
selection.f.cohorts = "CD",
max.offspring = 1,
mutation.rate = mut)
population <- breeding.diploid(population, breeding.size = c(400,0), name.cohort = "EFGH",
selection.m.cohorts = "EF",
selection.f.cohorts = "GH",
max.offspring = 1,
mutation.rate = mut)
population <- breeding.diploid(population, breeding.size = c(400,0), name.cohort = "S3",
selection.m.cohorts = "ABCD",
selection.f.cohorts = "EFGH",
max.offspring = 1,
mutation.rate = mut)
population <- breeding.diploid(population, breeding.size = c(400,0), name.cohort = "S3-DH",
dh.mating = TRUE, max.offspring = 2, dh.sex = 0,
selection.m.cohorts = "S3", selection.f.cohorts = "S3",
mutation.rate = mut)
# Extract information from the simulations
recombi <- get.recombi(population, cohorts = c("S3-DH"))
geno_founder <- geno_ori <- get.geno(population, cohorts = c("Founder")) # genotypes of the founders
change = sample(length(geno_founder), length(geno_founder)*geno_error_founder)
if(length(change)>0){
geno_founder[change] = 2 - geno_founder[change]
}
haplo <- get.haplo(population, cohorts = "S3-DH")[,1:400*2-1]*2
change = sample(length(haplo), length(haplo)*geno_error_off)
if(length(change)>0){
haplo[change] = 2 - haplo[change]
}
map <- get.map(population)
geno <- cbind(geno_founder, haplo)
recombi <- get.recombi(population, cohorts = c("S3-DH"))
population$breeding[[1]][[37]] = 1:8
true_founder = get.pool(population, cohorts = c("S3-DH"))
library(HaploBlocker)
# perform analysis for chromosome 1:
dhm = geno[map[,1]==1,] # haplotypes/genotypes of the founders
hhm = haplo[map[,1]==1,] # haplotypes of the offspring
dhm1 = geno_ori[map[,1]==1,]  # haplotypes/genotype without genotyping errors
# haplotype based estimation of founder segments
output = founder_detection(dhm = dhm, founding = 8, big_output = TRUE,
plot_overview = TRUE,
window_size = 10,
merging_error = 1)
#' Detection of founder segments
#'
#' Function to add off-variant-blocks
#' @param dhm haploid SNP-dataset (founders need to be in the first few columns)
#' @param dhm_founder haploid SNP-dataset of the founders
#' @param dhm_founder haploid SNP-dataset of the offspring
#' @param founding Number of founding haplotypes in the population
#' @param plot_overview Generate a plot of the lines chosen in lines_to_plot
#' @param plot_perline Generate an per line plot of estimated founders
#' @param min_condorance Minimum concordance of a segment to be assigned to a founder (default: 0; everything will be assigned)
#' @param multicolor Set to TRUE to indicate regions with multiple potentialy founder haplotypes by use of multiple colors
#' @param err Hidden Markov parameter (chance of error within a haplotype block; default: 0.025
#' @param err2 Hidden Markov parameter (chance of error outside of haplotype blocks; default: 0.1)
#' @param rec Hidden Markov parameter (chance of a recombination event between two markers; default: 0.001)
#' @param ped Pedigree - this will lead to lines only having founders from the lines given ancestors
#' @param weighting_length Weighting factor for length to determine major block (default: 1)
#' @param weighting_size Weighting factor for number of haplotypes in block to determine major block (default: 1)
#' @param min_majorblock minimum of cells in the dataset a block is the biggest covering (default: 5000)
#' @param target_coverage Target Coverage in the blocklist
#' @param big_output If TRUE return not only blocklist but also blockinfo, dataset ect.
#' @return Estimated Founder for each cell in the haploid dataset (dhm)
#' @export
#'
#'
founder_detection <- function(dhm=NULL, dhm_founder = NULL, dhm_off = NULL, founding = NULL, plot_perline=FALSE, plot_overview=TRUE,
lines_to_plot=1:50, min_concordance = 0, multicolor=FALSE,
err = 0.025, err2 = 0.1, rec = 0.0001, ped = NULL,
window_size = 5,
merging_error = 1,
weighting_length=2,
weighting_size=1,
target_coverage=NULL,
min_majorblock=NULL,
big_output = FALSE){
{
if(length(target_coverage)==0 & length(min_majorblock)==0){
min_majorblock = 1
}
if(length(target_coverage)==1 & length(min_majorblock)==0){
min_majorblock = 5000
}
if(length(dhm)==0){
dhm = cbind(dhm_founder, dhm_off)
founding = 1:ncol(dhm_founder)
}
if(length(founding)==1){
founding = 1:founding
} else if(length(founding)==0){
stop("Please provide the number of founders via the parameter founding")
}
nfounder <- length(founding)
noff <- ncol(dhm) - nfounder
recombi_list <- list()
line_cont <- matrix(0, nrow=nfounder, ncol=ncol(dhm)-nfounder)
genome_cont <- matrix(0, nrow=nfounder, ncol= nrow(dhm))
blocklist <- block_calculation(dhm, window_size = window_size,
merging_error = merging_error, min_similarity =  1,
min_majorblock = min_majorblock,
subgroups = list(founding, (1:ncol(dhm))[-founding]),
min_per_subgroup = 1,
weighting_length = weighting_length)
seq_table <- matrix(0, nrow=nrow(dhm), ncol=ncol(dhm)-nfounder)
t <- coverage_test(blocklist)
print(mean(t))
se <- blocklist_startend(blocklist)
print(mean(se[,2]-se[,1]))
overl <- numeric(length(blocklist))
for(index in 1:length(blocklist)){
overl[index] <- length(intersect(blocklist[[index]][[6]], founding))
}
k <- 1
if(plot_overview){
X11()
plot(0,0, ylim=c(1, length(lines_to_plot)+1), xlim=c(1, nrow(dhm)+1), ylab="line", xlab="SNP")
}
for(line in (nfounder+1):ncol(dhm)){
print(line)
subs <- list() # Start/end points of haplotype blocks
foundern <- list() # Potential founders (either of the two haplotypes of a founder)
for(index in 1:length(blocklist)){
if(sum(blocklist[[index]][[6]]==line)>0){
subs[[length(subs)+1]] <- c(blocklist[[index]][[2]]$snp, blocklist[[index]][[3]]$snp )
foundern[[length(foundern)+1]] <- intersect(blocklist[[index]][[6]], founding)
}
}
subs <- do.call(rbind,subs)
# version 2: extend haplotype blocks in case genotypes exactly match (still conservative!)
if(plot_perline){
X11()
plot(0,0, ylim=c(0,8), xlim=c(0,nrow(dhm)), ylab="founder", xlab="SNP")
}
avail <- matrix(FALSE, nrow=nrow(dhm), ncol=length(founding))
for(index in 1:nrow(subs)){
for(index2 in 1:length(founding)){
if(sum(foundern[[index]]==index2)>0){
if(plot_perline){
polygon(c(subs[index,1], subs[index,2], subs[index,2], subs[index,1]), c(index2-1,index2-1,index2,index2), col=index2, lty=0)
}
line_prior <- dhm[subs[index,1]:max(subs[index,1]-50,1),line]
founder_prior1 <- dhm[subs[index,1]:max(subs[index,1]-50,1),founding[index2]]
line_down <- dhm[subs[index,2]:min(subs[index,2]+50,nrow(dhm)),line]
founder_down1 <- dhm[subs[index,2]:min(subs[index,2]+50,nrow(dhm)),founding[index2]]
con1 <- c(line_prior==founder_prior1 , FALSE)
firstf1 <- which(con1==FALSE)[1]
con2 <- c(line_down==founder_down1, FALSE)
firstf2 <- which(con2==FALSE)[1]
if(plot_perline){
polygon(c(subs[index,1]-firstf1+1, subs[index,2]+firstf2-1, subs[index,2]+firstf2-1, subs[index,1]-firstf1+1), c(index2-1,index2-1,index2,index2), col=index2, lty=0)
}
avail[(subs[index,1]-firstf1+1):(subs[index,2]+firstf2-2), index2] <- TRUE
}
}
}
avail <- t(avail)
if(length(ped)>0){
avail_parent <- ped[which(ped[,1]==line),-1]
} else{
avail_parent <- NULL
}
## Forward - Algorithm:
forward <- matrix(0, nrow=length(founding), ncol=nrow(dhm))
forward[avail[,1],1] <- 1-err
forward[!avail[,1],1] <- err
if(length(avail_parent)>0){
forward[-avail_parent,1] <- 0
}
forward[,1] <- forward[,1] / sum(forward[,1])
rec_matrix <- matrix(rec, ncol=nfounder, nrow=nfounder)
diag(rec_matrix) <- 1 - rec
mult <- numeric(nfounder)
for(index in 2:nrow(dhm)){
mult[avail[,index]] <- 1 - err
mult[!avail[,index]] <- err
check1 <- (dhm[index,line] == dhm[index,founding]) & (mult == err)
mult[check1] <- 1 - err2
if(length(avail_parent)>0){
mult[-avail_parent] <- 0
}
forward[,index] <- mult * (t(forward[,index-1]) %*% rec_matrix)[,]
forward[,index] <- forward[,index] / sum(forward[,index])
}
## Backward - Algorithm
backward <- matrix(0, nrow=length(founding), ncol = nrow(dhm))
backward[,nrow(dhm)] <- 1 / nfounder
for(index in (nrow(dhm)-1):1){
mult[avail[,index]] <- 1 - err
mult[!avail[,index]] <- err
check1 <- dhm[index,line] == dhm[index,founding]
mult[check1] <- 1 - err2
if(length(avail_parent)>0){
mult[-avail_parent] <- 0
}
backward[,index] <- mult * (t(backward[,index+1]) %*% rec_matrix)[,]
backward[,index] <- backward[,index] / sum(backward[,index])
}
## Forward-Backward
if(FALSE && rb>0){
forward[forward<rb] <- rb
backward[backward<rb] <- rb
}
fb <- forward * backward
stand <- colSums(fb)
fb <- t(t(fb)/stand)
seq_line <- numeric(ncol(fb))
#imp_line <- rep("./.", nrow(map_ref))
if(plot_perline){
X11()
plot(fb[1,], type="l", col=1, lwd=2, ylim=c(0,1))
for(index in 2:8){
lines(fb[index,], col=index, lwd=2)
}
}
if(TRUE){
if(plot_overview) abline(h=k)
for(index in 1:nrow(dhm)){
temp <- which(fb[,index] == (max(fb[,index])))
if(length(temp)>1){
seq_line[index] <- sample(temp,1)
} else{
seq_line[index] <- temp
}
if(index>1 && fb[seq_line[index],index]<(fb[seq_line[index-1],index]+0.0001 )){
seq_line[index] <- seq_line[index-1]
}
}
}
cont <- matrix(0, nrow=length(founding), ncol = nrow(dhm))
for(index in 1:ncol(fb)){
cont[seq_line[index],index] <- 1
}
if(min_concordance>0){
breaks <- unique(c(0,which(diff(seq_line)!=0), length(seq_line)))
for(index in 1:(length(breaks)-1)){
cs <- (colSums(dhm[(breaks[index]+1):breaks[index+1], founding, drop=FALSE] == dhm[(breaks[index]+1):breaks[index+1], line]))
activ <- (which(rowSums(cont[,(breaks[index]+1):breaks[index+1], drop=FALSE])>0))
ll <- (breaks[index+1]-(breaks[index]))
if(max(cs[activ]/ll)<min_concordance){
seq_line[(breaks[index]+1):breaks[index+1]] <- 0
cont[,(breaks[index]+1):breaks[index+1]] <- 0
}
}
}
if(multicolor){
breaks <- unique(c(0,which(diff(seq_line)!=0), length(seq_line)))
for(index in 1:(length(breaks)-1)){
cs <- (colSums(dhm[(breaks[index]+1):breaks[index+1], founding, drop=FALSE] == dhm[(breaks[index]+1):breaks[index+1], line]))
activ <- (which(rowSums(cont[,(breaks[index]+1):breaks[index+1], drop=FALSE])>0))
ll <- (breaks[index+1]-(breaks[index]))
if(length(activ)>0){
if(min(cs[activ]) <= max(cs[-activ])){
if(length(avail_parent)>0){
cont[which(cs>=min(cs[activ])),(breaks[index]+1):breaks[index+1]] <- 1 / length(which(cs>=min(cs[activ])))
} else{
cont[intersect(avail_parent,which(cs>=min(cs[activ]))),(breaks[index]+1):breaks[index+1]] <- 1 / length(intersect(avail_parent,which(cs>=min(cs[activ]))))
}
}
} else if(sum((cs/ll) > min_concordance)>0){
if(length(avail_parent)>0){
cont[which((cs/ll) > min_concordance),(breaks[index]+1):breaks[index+1]] <- 1 / length(which((cs/ll) > min_concordance))
} else{
cont[intersect(avail_parent, which((cs/ll) > min_concordance)),(breaks[index]+1):breaks[index+1]] <- 1 / length(intersect(avail_parent, which((cs/ll) > min_concordance)))
}
}
}
}
for(index in 1:nrow(dhm)){
if(plot_overview && !multicolor ) polygon(c(index, index+1, index+1,index), c(k, k, k+1, k+1)-1, col = seq_line[index], lty=0)
if(plot_overview && multicolor){
cols <- which(cont[,index]>0)
ncc <- length(cols)
if(length(cols)>0){
for(nc in 1:ncc){
polygon(c(index, index+1, index+1,index), c(k, k, k+1/ncc, k+1/ncc)-1 + 1/ncc*(nc-1), col = cols[nc], lty=0)
}
}
}
}
recombi_event <- c(0,which(diff(seq_line)!=0))
recombi_list[[k]] <- list()
recombi_list[[k]][[1]] <- cbind(recombi_event+1, c(recombi_event[-1], nrow(dhm)))
recombi_list[[k]][[2]] <- list()
for(index in 1:length(recombi_event)){
recombi_list[[k]][[2]][[index]] <- which(cont[,recombi_event[index]+1]!=0)
}
if(plot_overview) abline(h=k)
k <- k+1
seq_table[,k-1] <- seq_line
line_cont[,line-nfounder] <- rowSums(cont)
genome_cont <- genome_cont + cont
}
if(big_output){
output = list(seq_table, line_cont, genome_cont)
return(output)
} else{
return(seq_table)
}
}
}
# perform analysis for chromosome 1:
dhm = geno[map[,1]==1,] # haplotypes/genotypes of the founders
hhm = haplo[map[,1]==1,] # haplotypes of the offspring
dhm1 = geno_ori[map[,1]==1,]  # haplotypes/genotype without genotyping errors
# haplotype based estimation of founder segments
output = founder_detection(dhm = dhm, founding = 8, big_output = TRUE,
plot_overview = TRUE,
window_size = 10,
merging_error = 1)
# extract real founders from MoBPS simulation
seq_true = true_founder[map[,1]==1,1:400*2]
save(file="C:/Users/pook001/OneDrive - Wageningen University & Research/hb_2025.RData",
list=c("output", "dhm", "hhm", "dhm1", "haplo"))
#load("C:/Users/pook001/OneDrive - Wageningen University & Research/hb.RData")
seq_est = output[[1]]
# Share of correct assignment
mean(seq_est==seq_true)
geno_est = matrix(0, ncol=ncol(haplo), nrow=nrow(seq_est))
geno_in = matrix(0, ncol=ncol(haplo), nrow=nrow(seq_est))
for(index in 1:8){
for(col in 1:400){
geno_est[seq_est[,col]==index, col] = dhm[seq_est[,col]==index,index]
geno_in[seq_true[,col]==index, col] = dhm1[seq_true[,col]==index,index]
}
}
mean((geno_est==hhm)[seq_est==seq_true])
mean((geno_est==hhm)[!(seq_est==seq_true)])
# do to mutations etc. even perfect assignment does not lead to 100% matching
mean((geno_in==hhm)[seq_est==seq_true])
mean((geno_in==hhm)[!(seq_est==seq_true)])
# Small visualiation of assigned founders for 25 haplotypes
plot(0,0, ylim=c(0,25), xlim=c(1,nrow(geno_est)))
for(k in 1:25){
for(index in 1:nrow(dhm)){
polygon(c(index, index+1, index+1,index), c(k-1, k-1, k, k), col = seq_est[index,k], lty=0)
}
}
# Assignments of the first 25 haplotypes and the underlying truth
plot(0,0, ylim=c(0,50), xlim=c(1,nrow(geno_est)))
for(k in 1:50){
for(index in 1:nrow(dhm)){
polygon(c(index, index+1, index+1,index), c(k*2-1, k*2-1, k*2, k*2)-1, col = seq_est[index,k], lty=0)
polygon(c(index, index+1, index+1,index), c(k*2-1, k*2-1, k*2, k*2), col = seq_true[index,k], lty=0)
abline(h=k*2)
}
}
# how correct is the assignment for each line
# founders 5 & 6 are basically in perfect IBD for the first half of chromosome 1
# substantially lower performance here
for(index in 1:8){
print(mean((seq_est==seq_true)[seq_true==index]))
}
plot(dhm[,5]==dhm[,6])
dim(dhm)
# Per line content of each founder per line
barplot(output[[2]][,1:50], col=1:8, main="Per line content share of each founder")
rowSums(output[[2]])
rowSums(output[[3]])
# Estimated
plot(output[[3]][1,], lwd=2, type="l", ylim=c(0, max(output[[3]])), ylab="frequency founder haplotype")
for(index in 2:8){
lines(output[[3]][index,], col=index, lwd=2)
}
# Real
plot(rowSums(seq_true==1), lwd=2, type="l", ylim=c(0, max(output[[3]])), ylab="frequency founder haplotype")
for(index in 2:8){
lines(rowSums(seq_true==index), col=index, lwd=2)
}
plot(output[[3]][1,]-rowSums(seq_true==1), lwd=2, type="l", ylim=c(-30, +30), ylab="frequency founder haplotype")
for(index in 2:8){
lines(output[[3]][index,]-rowSums(seq_true==index), col=index, lwd=2)
}
# Use of mpmap instead of founder_detection from haploblocker
nfounder = 8
library(mpMap2)
install.packages("mpMap2")
install.packages("C:/Users/pook001/Downloads/mpMap2_1.0.4.tar.gz", repos = NULL, type = "source")
install.packages("qtl")
install.packages("car")
install.packages("C:/Users/pook001/Downloads/mpMap2_1.0.4.tar.gz", repos = NULL, type = "source")
install.packages("sn")
install.packages("nnls")
install.packages("C:/Users/pook001/Downloads/mpMap2_1.0.4.tar.gz", repos = NULL, type = "source")
install.packages("fastcluster")
install.packages(pryr)
install.packages("C:/Users/pook001/Downloads/mpMap2_1.0.4.tar.gz", repos = NULL, type = "source")
install.packages("pryr")
install.packages("C:/Users/pook001/Downloads/mpMap2_1.0.4.tar.gz", repos = NULL, type = "source")
# Share of correct assignment
mean(seq_est==seq_true)
for(index in 1:8){
print(mean((seq_est==seq_true)[seq_true == index]))
}
{
# Use of mpmap instead of founder_detection from haploblocker
nfounder = 8
library(mpMap2)
dataset = dhm
## This is an exemplary use of mpmap2
dataset_mod = dataset
# dataset_mod[rowMeans(dataset[,1:nfounder])==0,] = 0
rownames(dataset_mod) = paste0("SNP", 1:nrow(dataset_mod))
# Extract founding line genotypes
founders <- t(dataset_mod[, 1:nfounder])*2
# Extract final population genotypes
finals <- t(dataset_mod[, (nfounder+1):ncol(dataset_mod)])*2
# Generate pedigree. I assume that you have 400 different ((1x2) x (3x4)) X ((5x6) X (7x8)) crosses, each of which is then inbred by selfing 400 times.
# This is very limited to specific breeding schemes. this basically just says that all founder can contribute to all offspring
pedigree <- eightParentPedigreeSingleFunnel(initialPopulationSize = ncol(dataset_mod) - nfounder, selfingGenerations = 6, intercrossingGenerations = 0)
# Put in the correct line names into the simulated pedigree
pedigree@lineNames[pedigree@observed] <- rownames(finals)
pedigree@lineNames[1:8] <- rownames(founders)
#Generate cross object. You have some invalid genotypes here, so I have set fixCodingErrors = TRUE.
#This automatically puts in NA instead of missing values. And also fixes a bunch of other types of errors.
cross <- mpcross(founders = founders, pedigree = pedigree, finals = finals, fixCodingErrors = TRUE)
#Apparently your errors are all invalid genotypes for the final genotypes, listed in errors$finals
errors <- listCodingErrors(founders = founders, finals = finals, hetData = infiniteSelfing(founders = founders, finals = finals, pedigree = pedigree))
# Set up a genetic map - idea is similar to my packages as this controlls frequency of recombination between SNPs
map_mp <- qtl::sim.map(len = 100, n.mar = nrow(dataset_mod), anchor.tel = TRUE,
include.x = FALSE, eq.spacing = TRUE)
names(map_mp[[1]]) <- rownames(dataset_mod)
# errorProb has a default of 0 but is then not robust towards any genotyping errors.
est_mp <- mpcrossMapped(cross, map_mp)
est1_mp <- computeGenotypeProbabilities(est_mp, errorProb = 0.01)
probs = est1_mp@geneticData@.Data[[1]]@probabilities@data
str(est1_mp)
# generate similar output to HaploBlocer with seq_est based on most likely founder
seq_est_mp = matrix(1, nrow = nrow(dataset), ncol = ncol(dataset) - nfounder)
for(index in 1:(ncol(dataset) - nfounder)){
print(index)
seq_indi = probs[1:nfounder + nfounder * (index - 1),]
for(ff in 2:nfounder){
change = (seq_indi[cbind(seq_est_mp[,index], 1:nrow(dataset))]) < (seq_indi[cbind(ff, 1:nrow(dataset))])
seq_est_mp[change,index] = ff
}
}
}
library(mpMap2)
install.packages("C:/Users/pook001/Downloads/mpMap2-0.0.6.zip", repos = NULL, type = "win.binary")
{
# Use of mpmap instead of founder_detection from haploblocker
nfounder = 8
library(mpMap2)
dataset = dhm
## This is an exemplary use of mpmap2
dataset_mod = dataset
# dataset_mod[rowMeans(dataset[,1:nfounder])==0,] = 0
rownames(dataset_mod) = paste0("SNP", 1:nrow(dataset_mod))
# Extract founding line genotypes
founders <- t(dataset_mod[, 1:nfounder])*2
# Extract final population genotypes
finals <- t(dataset_mod[, (nfounder+1):ncol(dataset_mod)])*2
# Generate pedigree. I assume that you have 400 different ((1x2) x (3x4)) X ((5x6) X (7x8)) crosses, each of which is then inbred by selfing 400 times.
# This is very limited to specific breeding schemes. this basically just says that all founder can contribute to all offspring
pedigree <- eightParentPedigreeSingleFunnel(initialPopulationSize = ncol(dataset_mod) - nfounder, selfingGenerations = 6, intercrossingGenerations = 0)
# Put in the correct line names into the simulated pedigree
pedigree@lineNames[pedigree@observed] <- rownames(finals)
pedigree@lineNames[1:8] <- rownames(founders)
#Generate cross object. You have some invalid genotypes here, so I have set fixCodingErrors = TRUE.
#This automatically puts in NA instead of missing values. And also fixes a bunch of other types of errors.
cross <- mpcross(founders = founders, pedigree = pedigree, finals = finals, fixCodingErrors = TRUE)
#Apparently your errors are all invalid genotypes for the final genotypes, listed in errors$finals
errors <- listCodingErrors(founders = founders, finals = finals, hetData = infiniteSelfing(founders = founders, finals = finals, pedigree = pedigree))
# Set up a genetic map - idea is similar to my packages as this controlls frequency of recombination between SNPs
map_mp <- qtl::sim.map(len = 100, n.mar = nrow(dataset_mod), anchor.tel = TRUE,
include.x = FALSE, eq.spacing = TRUE)
names(map_mp[[1]]) <- rownames(dataset_mod)
# errorProb has a default of 0 but is then not robust towards any genotyping errors.
est_mp <- mpcrossMapped(cross, map_mp)
est1_mp <- computeGenotypeProbabilities(est_mp, errorProb = 0.01)
probs = est1_mp@geneticData@.Data[[1]]@probabilities@data
str(est1_mp)
# generate similar output to HaploBlocer with seq_est based on most likely founder
seq_est_mp = matrix(1, nrow = nrow(dataset), ncol = ncol(dataset) - nfounder)
for(index in 1:(ncol(dataset) - nfounder)){
print(index)
seq_indi = probs[1:nfounder + nfounder * (index - 1),]
for(ff in 2:nfounder){
change = (seq_indi[cbind(seq_est_mp[,index], 1:nrow(dataset))]) < (seq_indi[cbind(ff, 1:nrow(dataset))])
seq_est_mp[change,index] = ff
}
}
}
library(mpMap2-0.0.6)
library(mpMap2)
install.packages("C:/Users/pook001/Downloads/mpMap2-0.0.6.zip", repos = NULL, type = "win.binary")
.libPaths()
install.packages("C:/Users/pook001/Downloads/mpMap2-0.0.6.zip", repos = NULL, type = "win.binary")
install.packages("C:/Users/pook001/Downloads/mpMap2-0.0.6.tar.gz", repos = NULL, type = "source")
install.packages("Heatplus")
BiocManager::install("Heatplus")
install.packages("C:/Users/pook001/Downloads/mpMap2-0.0.6.tar.gz", repos = NULL, type = "source")
devtools :: install_github("rohan-shah/mpMap2")
